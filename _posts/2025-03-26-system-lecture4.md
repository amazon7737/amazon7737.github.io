---
layout: post
title: ch04 대규모 시스템 설계 기초
tags: ["study"]
date: 2025-03-26T00:00:00+09:00
key: 2025-03-26 study
---


## 4장 처리율 제한 장치의 설계


처리율 제한 장치 : 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하기 위한 장치

### API 처리율 제한 장치를 두면 좋은 점

- DoS (Denial of Service) 공격 방지
- 비용 절감
- 서버 과부하를 막는다.

### 1단계 문제 이해 및 설계 범위 확정


#### 요구사항

- 설정된 처리율을 초과하는 요청은 정확하게 제한한다.
- 낮은 응답시간 : 처리율 제한 장치는 HTTP 응답시간에 나쁜 영향을 주어서는 곤란하다.
- 적은 메모리
- 분산형 처리율 제한 : 하나의 처리율 제한 장치를 여러 서버나 프로세스에 공유할 수 있어야 한다.
- 예외 처리 : 요청이 제한되었을 때는 그 사실을 사용자에게 분명하게 보여주어야 한다.
- 높은 결함 감내성 : 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안된다.


### 2단계 개략적 설계안 제시 및 동의 구하기

#### 처리율 장치의 위치


- 클라이언트 측
    - 위변조가 가능하여 권장하지 않는다.


- 서버 측
    - 중앙화해서 관리한다.

![image](https://github.com/user-attachments/assets/0a520c98-5cf4-43aa-8fad-00dc142345eb)

- 미들웨어
- MSA 인 경우, 처리율 제한 장치는 보통 API Gateway 에 구현한다.
- API Gateway : 처리율 제한, SSL 종단, 사용자 인증, IP 허용 목록 관리 등

![image](https://github.com/user-attachments/assets/13754840-be06-4edf-9530-190c5995e38d)


#### 요약

- 현재 기술 스택이 서버 측에 기능 구현이 가능한지 점검
- 상황에 맞는 알고리즘 사용, 만약 제3 사업자가 제공하는 API Gateway를 사용한다면 선택지는 제한이 될 수 있다.
- MSA 에 기반하고 있다면 인증, IP 허용 같은 기능을 이미 API Gateway 에 적용했을 수 있다. 그러면 처리율 제한도 API Gateway 에 포함하는 것이 좋다.
- 충분한 인력이 없다면 상용 솔루션도 고려해보는 것이 좋다.


### 처리율 제한 알고리즘

처리율 제한을 실현하는 알고리즘은 여러 가지 있는데, 각각 장단점과 특성을 알아보자.

#### 토큰 버킷 알고리즘

![image](https://github.com/user-attachments/assets/0859bd27-1d74-45f0-9e88-4cb323bb7f03)

- 토큰이 주기적으로 채워진다.
- 각 요청이 처리될 때마다 하나의 토큰을 사용한다.
- 토큰이 없다면 해당 요청은 버려진다.

![image](https://github.com/user-attachments/assets/8e28267f-e398-4906-8b4b-24e813f5cc8c)

![image](https://github.com/user-attachments/assets/4303ac3a-240c-443a-9a2e-928f4480445b)

- 토큰을 어떻게 버킷에서 꺼내는지
    - 4개의 토큰으로 시작
    - 요청은 전달됨
    - 1개 토큰이 소비됨

- 토큰 공급기는 어떻게 동작하는지
    - 3 토큰인 상태로 시작
    - 3개 요청 전부가 전달됨
    - 3개 토큰이 모두 소진됨

- 처리 제한 로직은 어떻게 작동하는지
    - 0 토큰인 상태로 시작
    - 요청은 버려짐

- 토큰 공급률은 분당 4개의 토큰이 생성되고 있다
    - 1분이 지나 4개의 토큰이 다시 공급됨

#### 인자(parameter)

- 버킷 크기 : 버킷에 담을 수 있는 최대 토큰의 개수
- 토큰 공급률 : 초당 몇 개의 토큰이 버킷에 공급되는가

#### 공급 제한 규칙

- 통상적으로 API 엔드포인트마다 별도의 버킷을 둔다.
- 하루에 한번만 포스팅 할 수 있고, 친구는 150명까지 추가할 수 있고, 좋아요 버튼은 다섯 번 까지만 누를 수 있다면, 사용자 마다 3개의 버킷을 두어야
- IP 주소별로 처리율 제한을 적용해야 한다면 IP 주소마다 버킷을 하나씩 할당해야 한다.
- 시스템의 처리율을 초당 10,000개 요청으로 제한하고 싶다면, 모든 요청이 하나의 버킷을 공유하도록 해야 할 것이다.

#### 장점

- 구현이 쉬움
- 메모리 효율적
- 짧은 시간에 집중 되는 트래픽도 잘 처리

#### 단점

- 버킷 크기 & 토큰 공급률 두 개의 인자를 필요로 하는 알고리즘이기에 적절하게 튜닝하는 것이 어렵다.


의문 : DB에 테이블에 count 하는 방법도 있지 않을까? DB에 부하가 걸리지만 이것을 도입하게 되는 경우는 시스템의 사용 속도가 많이 나오지 않을때 쓰는 것인지? 오버엔지니어링이 아닐까?


의문2 : 만약 오랫동안 사용하지 않는 사용자가 있다면, 어떻게 처리해야 할까?
리프레시 토큰, 세션(최근 로그인)이 오래된 경우 버킷을 제거
ex) 휴면계정으로 전환


### 누출 버킷 알고리즘


![image](https://github.com/user-attachments/assets/3e9cd8f3-bf11-4c9f-bcee-dd93a94fb516)

- 요청이 들어오면 큐가 가득 차 있는지 체크한다.
- 빈 자리가 있다면 큐에 요청을 추가한다.
- 만약 큐가 가득 차 있다면 요청은 버린다.
- 지정된 시간마다 큐에서 요청을 꺼내어 처리한다.
- 토큰 버킷 알고리즘과 비슷하지만, 요청 처리율이 고정되어 있다는 점이 다르다.
    - 큐에서 1초에 1개씩
- 보통 FIFO 큐로 구현한다.

#### 인자(parameter)

- 버킷 크기 : 큐 사이즈와 같은 값이다. 큐에는 처리될 항목들이 보관된다.
- 처리율 : 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값이다. 보통 초 단위로 표현된다.



#### 장점

- 큐에 크기가 제한되어 있어 메모리 효율적 사용
- 고정된 처리율을 가지고 있어 안정적 출력 (stable outflow rate) 이 필요한 경우 적합

#### 단점

- 단시간에 많은 트래픽이 몰리는 경우 최신 요청들이 버려지게 될 수 있음
- 토큰 버킷 알고리즘처럼 튜닝이 어려움 (버킷 크기 & 처리율)


### 고정 윈도 카운터 알고리즘


- 타임라인을 고정된 간격의 윈도(window)로 나누고, 각 윈도마다 카운터를 붙인다.
- 요청 접수 -> 카운터 + 1
- 카운터가 임계치에 도달 -> 새로운 요청은 새 윈도가 열릴때 까지 버려진다.

### 예시

![image](https://github.com/user-attachments/assets/987d1cef-b430-434f-a7d1-0ef7413568fa)

- 타임라인 시간 단위는 1초
- 초당 3개까지의 요청만을 허용
- 매초마다 열리는 윈도에 3개 이상의 요청이 밀려오면 초과분은 버려진다.

윈도 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 윈도에 할당된 양보다 더 많은 요청이 처리될 수 있음.

왜그럴까


![image](https://github.com/user-attachments/assets/39a36c9f-25df-45f4-b41e-a3088f3a3aed)

- 분당 최대 5개의 요청만을 허용
- 카운터는 매분마다 초기화

- 2:00:00 와 2:01:00 사이 다섯 개 요청이 들어옴
    - 2:01:00 과 2:02:00 사이에 또 다섯개의 요청이 들어옴
        - 윈도 위치를 조금 옮겨 2:00:30 부터 2:01:30 까지 1분동안 처리한 요청은 10개 허용 한도의 2배인 것

#### 장점

- 메모리 효율이 좋다.
- 이해하기 쉽다.
- Window 가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합하다.

#### 단점

- Window 경계 부근에 트래픽이 몰리면 설정한 임계치를 초과할 수 있다.

### 이동 윈도 로깅 알고리즘

- 타임스탬프를 추적하는 알고리즘이다.
- 타임스탬프 데이터는 보통 레디스의 sorted set 같은 캐시에 보관
- 새 요청이 오면 만료된 타임스탬프는 제거
- 로그의 크기가 허용치보다 같거나 작으면 시스템에 전달
- 허용치보다 크면 처리 거부


![image](https://github.com/user-attachments/assets/26516855-5b36-4748-87c0-853160803431)

- 분당 최대 2회의 요청만을 처리
- 요청이 1:00:01에 도착하였을때, 로그는 비어있는 상태, 요청이 허용됨

- 새로운 요청이 1:00:30 에 도착, 해당 타임스탬프가 로그에 추가됨
    - 추가 직후 로그의 크기는 2, 허용 한도보다 크지 않아 요청이 시스템에 전달됨

- 새로운 요청이 1:00:50에 도착, 해당 타임스탬프가 로그에 추가
    - 추가 직후 로그의 크기는 3으로, 허용 한도보다 큰 값 타임스탬프 로그는 남지만 요청은 거부됨

- 새로운 요청이 1:01:40에 도착, (1:00:40, 1:01:40 범위 안에 있는 요청은 1분 윈도 안에 있는 요청이지만, 1:00:40 이전의 타임스탬프는 전부 만료된 값이니 로그 삭제 처리. ㅑ
    - 삭제 직후 로그의 크기는 2이다. 1:01:40의 신규 요청은 시스템에 전달된다.

#### 장점

- 처리율 제한 메커니즘이 매우 정교하다.
- 어느 순간의 윈도를 보더라도 처리율 한도를 넘지 않는다.

#### 단점

- 거부된 요청의 타임스탬프도 보관하기 때문에 메모리를 많이 사용한다.


### 이동 윈도 카운터 알고리즘

- 고정 윈도 카운터 + 이동 윈도 로깅
- 현재 윈도에 몇 개의 요청이 온것으로 처리하는지
    - 현재 1분간의 요청 수 + 직전 1분간의 요청 수 X 이동 윈도와 직전 1분이 겹치는 비율


![image](https://github.com/user-attachments/assets/38958f27-c4ca-413d-acb7-baee96ca2196)

- 처리율 제한 장치 한도가 분당 7개 요청으로 설정
- 이전 1분 동안 5개의 요청이, 현재 1분 동안 3개의 요청이 왔다고 가정.
- 윈도에 들어 있는 요청은 3 + 5 X 70% = 6.5개이다. 본 예제에서는 내림하여 6
- 처리율 제한 한도가 분당 7개 요청이므로, 현재 1분의 30% 시점에 도착한 신규 요청은 시스템으로 전달 될 것임. 하지만 직후 한도에 도달하므로 더 이상 요청을 받을 수 없음

#### 장점

- 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽 대응에 용이
- 메모리 효율이 좋다.

#### 단점

- 직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정
- 따라서 추정치를 계산하기 때문에 100% 정확하지는 않다.
- 하지만 클라우드플레어에서 수행한 실험에 의하면 오탐은 0.003% 에 불과했다고 한다.

#### 개략적인 아키텍처

**알고리즘 재정리**

- 얼마나 많은 요청이 접수되었는지를 추적할 수 있는 카운터를 추적 대상별로 둠
- 사용자별 / IP 주소별 / API 엔드포인트 / 서비스 단위
- 카운터의 값이 한도를 넘어가면 한도를 넘어 도착한 요청은 거부


- 그렇다면 이 카운터는 어디 보관할 것인지?
- 디비는 디스크 접근 떄문에 느림 -> 메모리상에서 동작하는 캐시가 바람직
- 시간에 기반한 만료정책을 지원하는 캐시가 바람직
- 레디스(Redis) 를 자주 사용해볼수 있음
- INCR , EXPIRE 두가지  명령어를 활용

INCR : 카운터값 + 1
EXPIRE : 카운터 타임아웃 설정, 시간이 지나면 자동 삭제

![image](https://github.com/user-attachments/assets/1c21fa78-5b85-4361-8cd3-1a39ac69454e)

- 클라이언트가 처리율 제한 미들웨어에게 요청을 보냄
- 처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와서 한도에 도달했는지 검사
    - 한도에 도달했다면 요청은 거부
    - 한도에 도달하지 않았다면 요청은 API 서버로 전달 , 미들웨어가 카운터+1 시키고 레디스에 저장


### 3단계 상세 설계


### 처리율 제한 규칙

1. 처리율 한도 초과 트래픽 처리
   HTTP 429 응답 (Too many requests) : 어떤 요청이 한도 제한에 걸릴때 응답
   경우에 따라서 한도 제한에 걸린 메시지를 나중에 처리하기 위해 큐에 보관

2. 처리율 제한 장치가 사용하는 HTTP 헤더
   클라이언트가 자기 요청이 처리율 제한에 걸리고 있는지에 대한 정보를 아래 HTTP 헤더를 통해 전달

- X-Ratelimit-Remaining : 윈도 내에 남은 처리 가능 요청의 수
- X-Ratelimit-Limit : 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
- X-Ratelimit-Retry-After : 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림

사용자가 너무 많은 요청을 보내면 429 too many requests 오류 와 X-Ratelimit-Retry-After 헤더와 함께 반환시킨다

#### 상세 설계

![image](https://github.com/user-attachments/assets/4200dd21-fb3c-48db-837d-5b9b7a2bf8c1)

- 처리율 제한 규칙은 디스크에 보관, 작업 프로세스는 수시로 규칙을 디스크에서 읽어 캐시에 저장
- 클라이언트가 요청을 서버에 보내면 처리율 제한 미들웨어에 도달
    - 처리율 제한 미들웨어는 제한 규칙을 캐시에서 가져옴.
    - 카운터 및 마지막 요청의 타임스탬프를 레디스 케시에서 가져옴

- 가져온 값들에 근거하여 미들웨어는 해당 결정을 내림
    - 해당 요청이 처리율 제한에 걸리지 않은 경우 -> API 서버로
    - 해당 요청이 처리율 제한에 걸렸다면 429 too many requests 를 클라이언트에 반환
    - 해당 요청은 버릴수도 있고, 메시지 큐에 보관할 수도 있음

### 분산 환경에서의 처리율 제한 장치의 구현

여러 대의 서버와 병렬 스레드를 지원하도록 시스템을 확장하는 것에서는 다음과 같은 문제를 풀어야 한다.

#### 경쟁 조건 (race condition)

##### 이슈

경쟁 이슈가 발생하는 동작

##### 해결 방법

- 레디스에서 카운터의 값을 읽는다.
- counter + 1 의 값이 임계치를 넘는지 본다.
- 넘지 않는다면 레디스에 보관된 카운터 값을 1만큼 증가시킨다.

![image](https://github.com/user-attachments/assets/32caf90f-09ae-4120-9e0e-e13661309030)

- counter 의 값이 3이라고 하면, 두 개 요청을 처리하는 스레드가 각각 병렬로 counter 값을 읽었으며 그 둘 가운데 어느 쪽도 아직 변경된 값을 저장하지는 않은 상태라 하자.
- 둘 다 다른 요청의 처리 상태는 상관하지 않고 counter + 1 한 값을 레디스에 기록할 것이다. 그리고 올바르게 변경되었따고 믿을 것이다. 하지만 사실 Counter 의 값은 5가 되어야 한다.

  경쟁 조건 문제를 해결하는 널리 알려진 해결책은 락(lock) 이다. 하지만 락은 시스템 성능을 떨어뜨린다는 문제가 있다.

  락 대신 쓸 수 있는 해결책이 두 가지 있는데, 루아 스크립트(Lua Script) 이고 다른 하나는 정렬 집합(sorted set) 이라 불리는 레디스 자료구조를 쓰는 것

  **두 전략에 대해서 추가 조사가 필요해보인다.**

#### 동기화 이슈

![image](https://github.com/user-attachments/assets/505b9db6-92c4-4cb7-9ee6-4c03079ac88a)

##### 이슈

여러대의 처리율 제한 장치를 사용할 경우 요청이 분산될 수 있다.

##### 해결 방법

1. Sticky Session 을 사용하여 같은 클라이언트로부터 요청은 항상 같은 처리율 제한 장치로 보낼 수 있도록 할 수 있다. 단, 규모면에서 확장 가능하지 않아 추천하지 않는다.

2. 레디스와 같은 중앙 집중형 데이터 저장소를 쓰는 것이다.
![image](https://github.com/user-attachments/assets/2b3b8a9c-ebb4-42dc-90af-aab380f5c988)

#### 성능 최적화

시스템 설계 면접의 단골 주제.

##### 이슈

- 여러 데이터 센터를 지원하는 문제는 처리율 제한 장치에 매우 중요한 문제이다.
- 데이터센터에서 멀리 떨어진 사용자를 지원하려다 보면 latency는 증가할 수 밖에 없다.

##### 해결 방법

- 지연시간을 줄이기 위해 사용자의 트래픽을 가장 가까운 edge server로 전달하여 지연시간을 줄인다.

- 제한 장치 간에 데이터를 동기화 할 때 최종 일관성 모델을 사용하는 것이다.
    - 6장 "키-값 저장소 설계" 의 "데이터 일관성" 항목을 참고

#### 모니터링

모니터링을 통해서 확인할 것

- 채택된 처리율 제한 알고리즘
- 정의한 처리율 제한 규칙

상황

- 처리율 제한 규칙이 너무 빡빡하게 설정되어있다면 많은 유효 요청을 처리하지 못하고 버려질 것
- 깜짝 세일 같은 이벤트 때문에 트래픽이 급증할 때 처리율 제한 장치가 비효율적으로 동작한다면 트래픽 패턴을 잘 처리할 수 있도록 알고리즘을 바꾸는 것을 고려 -> 토큰 버킷이 적합할 수 있음

### 4단계 마무리

#### 경성(hard) 또는 연성(soft) 처리율 제한

경성 처리율 제한 : 요청의 개수는 임계치를 절대 넘어설 수 없다.
연성 처리율 제한 : 요청 개수는 잠시 동안은 임계치를 넘어설 수 있다.

#### 다양한 계층에서의 처리율 제한

애플리케이션 계층(7번 계층) 에서의 처리율 제한 외에도 다른 계층에서 제어
ex) Iptables를 사용하여 Ip 주소에 처리율 제한을 적용

#### 처리율 제한을 회피하는 방법, 클라이언트는 어떻게?

- 클라이언트 측 캐시를 사용하여 API 호출 횟수 줄이기
- 처리율 제한의 임계치를 적절히 설정하여, 짧은 시간 동안 너무 많은 메시지를 보내지 않도록
- 예외나 에러를 처리하는 코드를 도입하여, 클라이언트가 예외적 상황으로부터 우아하게 복구될 수 있도록한다.
- 재시도 로직을 구현할 때는 충분한 백오프 시간을 두도록
